\documentclass[a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{RJournal}
\usepackage{amsmath,amssymb,array}
\usepackage{booktabs}

%% load any required packages here

\begin{document}

%% do not edit, for illustration only
\sectionhead{Contributed research article}
\volume{XX}
\volnumber{YY}
\year{20ZZ}
\month{AAAA}

\begin{article}

  \title{An efficient and readable syntax for defining named capture
  regular expressions in R code}

\author{by Toby Dylan Hocking}

\maketitle

\abstract{Regular expressions are powerful tools for manipulating
  non-tabular textual data. For many tasks (visualization, machine
  learning, etc), tables of numbers must be extracted from such data
  before processing by other R functions. We present the R package
  \CRANpkg{namedCapture}, which facilitates such tasks by providing a new
  user-friendly syntax for defining regular expressions in R code. We
  begin by describing the history of regular expressions and their
  usage in R. We then describe the new features of the namedCapture
  package, and provide detailed comparisons with related R packages
  (\CRANpkg{rex}, \CRANpkg{stringr}, \CRANpkg{stringi}, \CRANpkg{tidyr},
  \CRANpkg{rematch2}, \CRANpkg{re2r}).}

\section{Introduction}

Today regular expression libraries are powerful and widespread tools
for text processing. A regular expression \dfn{pattern} is
typically a character string that defines a set of possible
\dfn{matches} in some other \dfn{subject} strings. For example
the pattern \code{o+} matches one or more lower-case o characters; it
would match the last two characters in the subject \code{foo}, and it
would not match in the subject \code{bar}. 

The focus of this article is regular expressions with capture groups,
which are used to extract subject substrings. Capture groups are
typically defined using parentheses. For example, the pattern
\code{[0-9]+} matches one or more digits (e.g. \code{314} but not
\code{3.14}), and the pattern \code{[0-9]+-[0-9]+} matches a range of
digits (e.g. \code{9-5}). The pattern \code{([0-9]+)-([0-9]+)} will
perform matching identically, but provides access by number/index to
the strings matched by the capturing sub-patterns enclosed in
parentheses (group 1 matches \code{9}, group 2 matches \code{5}). The
pattern \code{(?P<start>[0-9]+)-(?P<end>[0-9]+)} further provides access
by name to the captured sub-strings (\code{start} group matches
\code{9}, \code{end} group matches \code{5}). In R named capture
groups are useful in order to create more readable regular expressions
(names document the purpose of each sub-pattern), and to create more
readable R code (named references to captured groups are better than
numbered references).

We begin by providing a brief history of regular
expressions and their usage in \R. We then provide an overview of
current R packages for regular expressions.

\subsection{Origin of regular expressions and named capture groups}

Regular expressions were first proposed on paper
by \citet{Kleene56}. Among the first uses of a regular expression in
computers was for searching in a text editor \citep{Thompson68} and
lexical processing of source code \citep{Johnson68}. 

A capture group in a regular expression is used to extract text that
matches a sub-pattern. In 1974, Thompson wrote the \texttt{grep}
command line program, which was among the first to support capture
groups \citep{Friedl2002}. In that program, backslash-escaped
parentheses \verb|\(\)| were used to open and close each capture
group, which could then be referenced by number (\verb|\1| for the
first capture group, etc).

The idea for named capture groups seems to have originated in 1994
with the contributions of Tracy Tims to Python 1.0.0, which used the
\verb|\(<labelname>...\)| syntax
\citep{Python-1.5.2-Misc-HISTORY}. Python 1.5 introduced the
\verb|(?P<labelname>...)| syntax for name capture groups
\citep{python-1.5-Doc-libre.tex}; the P was used to indicate that the
syntax was a Python extension to the standard.

Perl-Compatible Regular Expressions (PCRE) is a C library that is now
a widely used in free/open-source software tools such as Python and R.
PCRE introduced support for named capture in 2003, based on the Python
syntax \citep{pcre1-changelog.txt}. Starting in 2006, it supported the
\verb|(?P<labelname>...)| and \verb|(?'labelname'...)| syntax, to be
consistent with Perl and .NET \citep{pcre1-changelog.txt}.

The first regular expression support in R was provided by the TRE C
library \citep{TRE}. Although TRE supports capture groups, it does not
allow capture groups to be named. PCRE was first included in R version
1.6.0 in 2002 \citep{R.NEWS.1.txt}. The base R functions
\code{regexpr} and \code{gregexpr} can be given the \code{perl=TRUE}
argument in order to use the PCRE library, or \code{perl=FALSE} to use
the TRE C library. A major difference between the two libraries is
that TRE provides fast polynomial time match algorithms, whereas PCRE
is exponential time in the worst case. Although for most patterns the
time difference is negligible, malicious patterns can make PCRE run
quite a bit slower (Section~\ref{sec:timings}).

The original versions of \code{regexpr} and \code{gregexpr} only
returned the position/length of the text matched by an entire regex,
not the capture groups (even though this is suppored in TRE/PCRE). I
wrote the C code that uses PCRE to extract the text matched by each
named capture group \citep{HockingBug2011}, which was accepted into R
starting with version 2.14. I presented a lightning talk at useR 2011
that showcased the new functionality \citep{HockingUseR2011}.

\subsection{Related R packages for capturing regular expressions}

\begin{table}
  \centering
\begin{tabular}{llll}
Package      & First match              & All matches             & C library  \\
\hline
 \pkg{base}         & \code{regexpr}                  & \code{gregexpr}                & PCRE/TRE \\
  \pkg{utils}        & \code{strcapture}               & NA                      & PCRE/TRE \\
  \CRANpkg{rematch2}     & \code{re\_match}                 & \code{re\_match\_all}            & PCRE/TRE\\
  \CRANpkg{namedCapture} & \code{str\_match\_*}, \code{df\_match\_variable}          & str\_match\_all\_*     & PCRE/RE2\\
  \CRANpkg{rex}          & \code{re\_matches(global=FALSE)} & \code{re\_matches(global=TRUE)} & PCRE\\
  \CRANpkg{stringr}      & \code{str\_match}                & \code{str\_match\_all}           & ICU\\
  \CRANpkg{stringi}      & \code{stri\_match}               & \code{stri\_match\_all}          & ICU\\
  \CRANpkg{tidyr}        & \code{extract}                  & NA                      & ICU\\
  \CRANpkg{re2r}         & \code{re2\_match}                & \code{re2\_match\_all}           & RE2
\end{tabular}
  \caption{R packages that provide functions for extracting first/all regex matches, and C library used.}
  \label{tab:Clib}
\end{table}


\begin{table}
  \centering
\begin{tabular}{llllll}
Package & subject & pattern      & outputs     & named & types \\
\hline
\pkg{base} & chr     & chr          & mat/list    & yes   & no    \\
\code{utils::strcapture} & chr     & chr          & df          & no    & some  \\
\CRANpkg{rematch2} & chr     & chr          & tibble      & yes   & no    \\
\CRANpkg{namedCapture} & chr/df/dt   & verbose      & mat/list/df/dt       & yes   & any   \\
\CRANpkg{rex} & chr     & verbose      & df/list          & yes   & no    \\
\CRANpkg{stringr} & chr     & chr          & mat/list    & no    & no    \\
\CRANpkg{stringi} & chr     & chr          & mat/list    & no    & no    \\
\code{tidyr::extract} & df/dt   & chr          & df/dt       & no    & some  \\
\CRANpkg{re2r} & chr     & chr/compiled & df/list     & yes   & no    
\end{tabular}
  \caption{R packages provide different options for subject/pattern input, extracted text outputs, named capture groups, and type conversion.}
  \label{tab:features}
\end{table}

Since the introduction of named capture support in base R version
2.14, several packages have been developed which use this
functionality, and other packages have been developed which use other
C libraries (Table~\ref{tab:Clib}). Each package supports different
options for subject/pattern input, extracted text outputs, named
capture groups, and type conversion (Table~\ref{tab:features}).

The \pkg{utils} package now includes the strcapture function, which uses the
base regexec function (also introduced in R-2.14) to extract the first
match as a data.frame with one row per subject, and one column per
capture group. It allows capture group names/types to be specified in
a prototype data.frame argument, but does not allow capture group
names in the regex pattern itself. PCRE is used with \code{perl=TRUE}
and TRE is used with \code{perl=FALSE}.
 
The \CRANpkg{rematch2} package provides the \code{re\_match} function which
extracts the first match using the base \code{regexpr} function
\citep{rematch2}. It also provides the \code{re\_match\_all} function
which extracts all matches using the base \code{gregexpr} function. In
both cases the output is a tibble (a data.frame subclass) with one row
for each subject (for all matches a list column is used). PCRE is used
with \code{perl=TRUE} and TRE is used with \code{perl=FALSE}. Although
TRE supports capture groups (and can be used via the base R regexec
function), capture groups are not supported in rematch2 with
\code{perl=FALSE} (because it uses the base regexpr/gregexpr functions
which do not return group info for TRE). Named capture groups are
supported in rematch2 with \code{perl=TRUE}.

The \CRANpkg{stringi} package provides the \code{stri\_match} and
\code{stri\_match\_all} functions, which use the ICU C library
\citep{stringi}. The stringr package provides the \code{str\_match} and
\code{str\_match\_all} functions, which simply call the analogous
functions from stringi. Capture groups are supported but named groups
are not, so groups must be extracted by number. The \code{stri\_match}
function returns a character matrix with one row for each subject and
one column for each capture group. The \code{stri\_match\_all} function
returns a list with one element for each subject; each element is a
data frame with one row for each match, and one column for each
capture group.

The \CRANpkg{re2r} package provides the \code{re2\_match} and
\code{re2\_match\_all} functions, which use the RE2 C++ library
\citep{re2r}. The outputs of these functions are consistent with the
\CRANpkg{stringi}/\CRANpkg{stringr} packages. The input regex pattern may be specified as
a character string or as a pre-compiled regex object (which
results in faster matching if the regex is used with several calls to
matching functions). Like TRE, the RE2 library guarantees polynomial
time complexity, which is useful to avoid denial-of-service attacks
from malicious patterns (see Section~\ref{sec:timings}).

The \CRANpkg{rex} package provides the \code{re\_matches} function which supports
named capture groups, and always uses PCRE \citep{rex}. By default it
returns the first match (using the base \code{regexpr} function), as a
data.frame with one row for each subject, and one column for each
capture group. If the \code{global=TRUE} argument is given,
\code{gregexpr} is used to return all matches as a list of
data.frames. A unique feature of the \CRANpkg{rex} package is a set of functions
for defining a regular expression in R code, which is then converted
to a standard PCRE regex pattern string (for a detailed comparison
with the proposed syntax of the \CRANpkg{namedCapture} package, see
Section~\ref{sec:rex}).

The \CRANpkg{tidyr} package provides the \code{extract} function which uses the
ICU library, so does not support regex patterns with named capture
groups \citep{tidyr}. The subject is specified via the first two
arguments: (1) a data.frame, and (2) a column name. The pattern is
specified via the second two arguments: (3) a character vector for the
capture group names, and (4) the regex pattern string (it is an error
if the number of capture group names does not match the number of
capture groups in the regex pattern). The pattern is used to find the
first match in each subject. The return value is a data.frame with the
same number of rows as the input, but without the subject column, and
with an additional column for each capture group.


\section{The \CRANpkg{namedCapture} package}

The \CRANpkg{namedCapture} package provides functions for extracting
numeric data tables from non-tabular text data using named capture
regular expressions. By default, \CRANpkg{namedCapture} uses the RE2 C
library if the \CRANpkg{re2r} package is available, and PCRE otherwise
(via the base \code{regexpr} and \code{gregexpr} functions).
The main design features of the namedCapture package are
inspired by the base R system, which provides good support for
naming objects, and referring to objects by name. In particular, the namedCapture package supports 
\begin{itemize}
\item Specifying capture groups with names in a regular expression
  string, and stopping with an informative error if there are un-named
  capture groups.
\item Output with rownames or list names taken from the \code{name} capture group.
\item A syntax for specifying capture group names via named arguments
  in R code.
\item Specifying a function for each named capture group,
  which converts captured text from character to other arbitrary types.
\item Saving sub-patterns to R variables, and re-using them multiple
  times in one or several patterns in order to avoid repetition.
\end{itemize}

The main functions provided by the namedCapture package are summarized
in Table~\ref{tab:functions}. We begin by introducing the \code{*\_named} functions, which take three arguments.

\begin{table}
  \centering \begin{tabular}{llll}
  First match & All matches &  Arguments \\
  \hline
  \code{str\_match\_named} & \code{str\_match\_all\_named} & chr subject, chr pattern, functions \\
  \code{str\_match\_variable}  & \code{str\_match\_all\_variable} & chr subject, chr/list/function,  ... \\
  \code{df\_match\_variable} & NA & df subject,  chr/list/function, ...
  \end{tabular}
  \caption{Functions of the
  namedCapture package. The first argument of each function specifies
  the subject, as either a character vector (for \texttt{str\_*})
  functions, or a data.frame
  (for \texttt{df\_match\_variable}). The \texttt{*\_named} functions
  require three arguments, whereas the \texttt{*\_variable} functions
  take a variable number of arguments.}  \label{tab:functions}
\end{table}

\subsection{Three argument syntax: \code{str\_match\_named} and \code{str\_match\_all\_named}}

The most basic functions of the \CRANpkg{namedCapture} package
are \code{str\_match\_named} and \code{str\_match\_all\_named}, which accept exactly three arguments:
\begin{itemize}
\item subject: a character vector from which we want to extract
  tabular data.
\item pattern: the (character scalar) regular expression with named
  capture groups used for extraction.
\item fun.list: a list with names that correspond to capture groups,
  and values are functions used to convert the extracted character
  data to other (typically numeric) types.
\end{itemize}

For an example, we consider subjects containing genomic positions:

<<subject>>=

chr.pos.subject <- c(
  "chr10:213,054,000-213,055,000",
  "chrM:111,000",
  "this will not match",
  NA, # neither will this.
  "chr1:110-111 chr2:220-222") # two possible matches.

@

These subjects consist of a chromosome name string, a colon, a start
position, and optionally a dash and and end position. The following
pattern is used to extract those data:

<<chrPosPattern>>=

chr.pos.pattern <- paste0(
  "(?P<chrom>chr.*?)",
  ":",
  "(?P<chromStart>[0-9,]+)",
  "(?:",
    "-",
    "(?P<chromEnd>[0-9,]+)",
  ")?")

@

The pattern above is defined using paste0, writing each named capture
group on a separate line, which increases readability of the pattern.
By default
the \code{str\_match\_named} function returns a character matrix with
one row for each subject and one column for each capture group. Column
names are taken from the group names that were specified in the
regular expression pattern:

<<chrPosNoTypes>>=

(match.mat <- namedCapture::str_match_named(
  chr.pos.subject, chr.pos.pattern))

@


Note that the third argument (list of conversion functions) is omitted
in the code above. In that case, the return value is a character
matrix, in which missing values indicate missing subjects or no
match. The empty string is used for optional groups which are not used
in the match (e.g. chromEnd group/column for second subject).

However we often want to extract numeric data; in this case we want to
convert chromStart/End to integers. You can do that by supplying a
named list of conversion functions as the third argument. Each
function should take exactly one argument, a character vector (data in
the matched column/group), and return a vector of the same size. The
code below specifies the int.from.digits function for both chromStart
and chromEnd:

<<chrPosNoTypes>>=

int.from.digits <- function(captured.text){
  as.integer(gsub("[^0-9]", "", captured.text))
}
conversion.list <- list(
  chromStart=int.from.digits,
  chromEnd=int.from.digits)
(match.df <- namedCapture::str_match_named(
  chr.pos.subject, chr.pos.pattern, conversion.list))

@

Note that a data.frame is returned when the third argument is
specified, in order to handle non-character data types returned by the
conversion functions.

In the examples above the last subject has two possible
matches, but only the first is returned by \code{str\_match\_named}. Use
\code{str\_match\_all\_named} to get all matches in each subject (not just the
first match).

<<allChrPos>>=

namedCapture::str_match_all_named(
  chr.pos.subject, chr.pos.pattern, conversion.list)

@

As shown above, the result is a list with one element for
each subject. Each list element is a data.frame with one row for each
match.

\subsection{Named output for named subjects}

If the subject is named, its names will be used to name the output
(rownames or list names).

<<namedSubject>>=

named.subject <- c(
  ten="chr10:213,054,000-213,055,000",
  M="chrM:111,000",
  two="chr1:110-111 chr2:220-222") # two possible matches.
namedCapture::str_match_named(
  named.subject, chr.pos.pattern, conversion.list)
namedCapture::str_match_all_named(
  named.subject, chr.pos.pattern, conversion.list)

@

This feature makes it easy to select particular subjects/matches by
name. 

\subsection{The \code{name} group specifies row names of output}

If the pattern specifies the \code{name} group, then it will be used
for the rownames of the output, and it will not be included as a
column. However if the subject has names, and the \code{name} group is
specified, then to avoid losing information the subject names are used
to name the output (and the \code{name} column is included in the
output).

<<namedSubjectPattern>>=

name.pattern <- paste0(
  "(?P<name>chr.*?)",
  ":",
  "(?P<chromStart>[0-9,]+)",
  "(?:",
    "-",
    "(?P<chromEnd>[0-9,]+)",
  ")?")
namedCapture::str_match_named(
  named.subject, name.pattern, conversion.list)
namedCapture::str_match_all_named(
  named.subject, name.pattern, conversion.list)

@

\subsection{Readable and efficient variable argument syntax used in \code{str\_match\_variable}}

In this section we introduce the variable argument syntax used in the
\code{*\_variable} functions. This new syntax is both readable and
efficient, because it is motivated by the desire to avoid
repetitive/boilerplate code. In the previous sections we defined the
pattern using the paste0 boilerplate, which is used to break the
pattern over several lines for clarity. We begin by introducing
\code{str\_match\_variable}, which extracts the first match from each
subject. Using the variable argument syntax, we can omit paste0, and
simply supply the pattern strings to \code{str\_match\_variable}
directly,

<<strMatchNamed>>=

namedCapture::str_match_variable(
  named.subject, 
  "(?P<chrom>chr.*?)",
  ":",
  "(?P<chromStart>[0-9,]+)",
  "(?:",
    "-",
    "(?P<chromEnd>[0-9,]+)",
  ")?")

@

We can further simplify by removing the named capture groups from the
strings, and adding names to the corresponding arguments. For
\code{name1="pattern1"}, namedCapture internally generates/uses the regex
\code{(?P<name1>pattern1)}.

<<namedArgs>>=

namedCapture::str_match_variable(
  named.subject, 
  chrom="chr.*?",
  ":",
  chromStart="[0-9,]+",
  "(?:",
    "-",
    chromEnd="[0-9,]+",
  ")?")

@

We can add type conversion functions on the same line as the
definition of the named group:

<<inlineconversion>>=

namedCapture::str_match_variable(
  named.subject, 
  chrom="chr.*?",
  ":",
  chromStart="[0-9,]+", int.from.digits,
  "(?:",
    "-",
    chromEnd="[0-9,]+", int.from.digits,
  ")?")

@

Note the repetition in the chromStart/End lines --- the same pattern
and type conversion function is used for each group. This repetition
can be avoided by creating and using a sub-pattern list variable,

<<subPatternList>>=

int.pattern <- list("[0-9,]+", int.from.digits)
namedCapture::str_match_variable(
  named.subject, 
  chrom="chr.*?",
  ":",
  chromStart=int.pattern,
  "(?:",
    "-",
    chromEnd=int.pattern,
  ")?")

@

Finally, the non-capturing group can be replaced by an un-named list:

<<nonCapturingList>>=

namedCapture::str_match_variable(
  named.subject, 
  chrom="chr.*?",
  ":",
  chromStart=int.pattern,
  list(
    "-",
    chromEnd=int.pattern
  ), "?")

@

In summary, the \code{str\_match\_variable} function takes a variable number of arguments, and allow for a shorter, less repetitive, and thus more user-friendly syntax:
\begin{itemize}
\item The first argument is the subject character vector.
\item The other arguments specify the pattern, via character strings,
  functions, and/or lists.
\item If a pattern (character/list) is named, we use the argument name in R for the capture
  group name in the regex.
\item Each function is used to convert the text extracted by the previous
  named pattern argument. (type conversion can only be used with named R arguments, NOT with explicitly specified named groups in regex strings)
\item R sub-pattern variables
  may be used to avoid repetition in the definition of the pattern and type conversion functions.
\item Each list generates a group in the regex (named list = named capture group, un-named list = non-capturing group).
\item All patterns are pasted together in the order that they appear in
  the argument list.
\end{itemize}

\subsection{Extract all matches from a multi-line text file via \code{str\_match\_all\_variable}}

\label{sec:trackDb}

The variable argument syntax can also be used with
\code{str\_match\_all\_variable}, which is for the common case of extracting
each match from a multi-line text file. In this section we demonstrate
how to use \code{str\_match\_all\_variable} to extract data.frames from a
loosely structured text file.

<<trackDb>>=

trackDb.txt.gz <- system.file(
  "extdata", "trackDb.txt.gz", package="namedCapture")
trackDb.lines <- readLines(trackDb.txt.gz)

@

Some representative lines from that file are shown below.

<<catTrackDB>>=

cat(trackDb.lines[78:107], sep="\n")

@

Each block of text begins with \code{track} and includes several lines of
data before the block ends with two consecutive newlines. That pattern
is coded below:

<<fieldsDF>>=

fields.mat <- namedCapture::str_match_all_variable(
  trackDb.lines,
  "track ",
  name="\\S+",
  fields="(?:\n[^\n]+)*",
  "\n")
head(substr(fields.mat, 1, 50))

@

Note that this function assumes that its subject is a character vector
with one element for each line in a file. The elements are pasted
together using newline as a separator, and the regex is used to find
all matches in the resulting multi-line string. The code above creates
a data frame with one row for each track block, with rownames given by
the track line (because of the capture group named name), and one
fields column which is a string with the rest of the data in that
block.

Each block has a variable number of lines/fields. Each line starts
with a field name, followed by a space, followed by the field
value. That regex is coded below:

<<fieldsList>>=

fields.list <- namedCapture::str_match_all_named(
  fields.mat[, "fields"], paste0(
    "\\s+",
    "(?P<name>.*?)",
    " ",
    "(?P<value>[^\n]+)"))
fields.list$bcell_McGill0091Coverage

@

The result is a list of data frames. 
There is a list element for each block, named by track. Each list
element is a data frame with one row per field defined in that
block (rownames are field names). The names/rownames make it easy
to write R code that selects individual elements by name.

In the example above we extracted all fields from all tracks (using
two regexes, one for the track, one for the field). In the example
below we extract only the bigDataUrl field for each track, and split
components of each sample name into separate columns (using a single
regex for the track). It also demonstrates how to use nested named
capture groups, via a named list such as \code{trackName.pattern}
below which contains other named patterns.

<<trackDbMatchAll>>=

trackName.pattern <- list(
  cellType=".*?",
  "_",
  sampleName=list(
    "McGill",
    sampleID=int.pattern),
  dataType="Coverage|Peaks",
  "|",
  "[^\n]+")
match.df <- namedCapture::str_match_all_variable(
  trackDb.lines,
  "track ",
  name=trackName.pattern,
  "(?:\n[^\n]+)*",
  "\\s+bigDataUrl ",
  bigDataUrl="[^\n]+")
match.df["bcell_McGill0091Coverage", c("cellType", "sampleName", "sampleID", "dataType")]

@

Exercise for the reader: modify the above in order to capture
three additional columns (red, green, blue) from the color field.

\subsection{\code{df\_match\_variable} extracts new columns from character columns in a data.frame}

\label{sec:df_match_variable}

We also provide \code{namedCapture::df\_match\_variable} which extracts text
from several columns of a data.frame, using a different named capture
regular expression for each column.

\begin{itemize}
\item It requires a data.frame as the first argument.
\item It takes a variable number of other arguments, all of which must be
  named. For each other argument we call \code{str\_match\_variable} on one
  column of the input data.frame.
\item Each argument name specifies a column of the data.frame which will
  be used as the subject in \code{str\_match\_variable}.
\item Each argument value specifies a pattern, in
  list/character/function variable argument syntax.
\item The return value is a data.frame with the same number of rows as the
  input, but with an additional column for each named capture
  group. New columns are named using the convention
  \code{subjectColumnName.groupName}.
\end{itemize}
This function can greatly simplify the code required to create numeric
data columns from character data columns. For example consider the
following data which was output from the SLURM sacct command line program.

<<sacctdf>>=

(sacct.df <- data.frame(
  Elapsed=c("07:04:42", "07:04:42", "07:04:49", "00:00:00", "00:00:00"),
  JobID=c("13937810_25", "13937810_25.batch", "13937810_25.extern",
    "14022192_[1-3]", "14022204_[4]"), stringsAsFactors=FALSE))

@

Say we want to filter by the total Elapsed time (which is reported as
hours:minutes:seconds), and base job id (which is the number before
the underscore in the JobID column). We begin by defining a pattern
that matches a range of integer task IDs in square brackets, and applying that
pattern to the JobID column:

<<rangePat>>=

range.pattern <- list(
  "[[]",
  task1=int.pattern,
  list(
    "-",
    taskN=int.pattern
  ), "?",
  "[]]")
namedCapture::df_match_variable(sacct.df, JobID=range.pattern)

@ 

The result shown above is another data frame with an additional column for each
named capture group. 
Next, we define another pattern that matches either one task ID
or the previously defined range pattern:

<<taskPat>>=

task.pattern <- list(
  "_", list(
    task=int.pattern,
    "|",#either one task(above) or range(below)
    range.pattern))
namedCapture::df_match_variable(sacct.df, JobID=task.pattern)

@ 

Finally, we use the previously defined patterns to match the complete JobID
column, along with the Elapsed column:

<<dfMatchVar>>=

namedCapture::df_match_variable(
  sacct.df,
  JobID=list(
    job=int.pattern,
    task.pattern,
    list(
      "[.]",
      type=".*"
    ), "?"),
  Elapsed=list(
    hours=int.pattern,
    ":",
    minutes=int.pattern,
    ":",
    seconds=int.pattern))

@

The code above specifies two named arguments to
\code{df\_match\_variable}. Each named argument specifies a column from
which tabular data are extracted using the corresponding pattern. The
final result is a data frame with additional columns for each named
capture group. 

\section{Comparisons with other R packages}
\label{sec:comparisons}

In this section we compare the proposed functions in the \CRANpkg{namedCapture}
package with similar functions in other R packages for regular expressions.

\subsection{Comparing \CRANpkg{namedCapture} variable argument syntax with \CRANpkg{rex}}
\label{sec:rex}
In this section we compare namedCapture verbose variable argument
syntax with the similar rex package. We have adapted the log
parsing example from the rex package:

<<logsubject>>=

log.subject <- 'gate3.fmr.com - - [05/Jul/1995:13:51:39 -0400] "GET /shuttle/countdown/ 
curly02.slip.yorku.ca - - [10/Jul/1995:23:11:49 -0400] "GET /sts-70/sts-70-patch-small.gif
boson.epita.fr - - [15/Jul/1995:11:27:49 -0400] "GET /movies/sts-71-mir-dock.MPG
134.153.50.9 - - [13/Jul/1995:11:02:50 -0400] "GET /icons/text.xbm'
log.lines <- strsplit(log.subject, split="\n")[[1]]

@ 

The goal is to extract the time and filetype for
each log line. The code below uses the \code{rex} function to define a
pattern for matching the filetype: 

<<rex>>=

library(rex)
library(dplyr)
(rex.filetype.pattern <- rex(
  non_spaces, ".",
  capture(name = 'filetype',
          none_of(space, ".", "?", double_quote) %>% one_or_more())))

@ 

Note that rex defines R functions (e.g. \code{capture},
\code{one\_or\_more}) and constants (\code{non\_spaces},
\code{double\_quote}) which are translated to standard regular expression
syntax via the \code{rex} function. These regex objects can be used as
sub-patterns in other calls to \code{rex}, as in the code below:

<<rexFull>>=

rex.pattern <- rex(
  "[",
  capture(name = "time", none_of("]") %>% zero_or_more()),
  "]",
  space, double_quote, "GET", space,
  maybe(rex.filetype.pattern))

@ 

Finally, the rex pattern is used with \code{re\_matches} in order to
extract a data table, and the mutate function is used for type
conversion:

<<reMatches>>=

re_matches(log.lines, rex.pattern) %>% mutate(
  filetype = tolower(filetype),
  time = as.POSIXct(time, format="%d/%b/%Y:%H:%M:%S %z"))

@


Using the namedCapture package we begin by defining an analogous
filetype pattern as a list containing literal regex strings and a type
conversion function:

<<lognamedcapture>>=

namedCapture.filetype.pattern <- list(
  "[^[:space:]]+[.]", 
  filetype='[^[:space:].?"]+', tolower)

@ 

We can then use that as a sub-pattern in a call to
\code{str\_match\_variable}, which results in a data table with columns
generated via the specified type conversion functions:

<<s>>=

namedCapture::str_match_variable(
  log.lines,
  "\\[",
  time="[^]]*", function(x)as.POSIXct(x, format="%d/%b/%Y:%H:%M:%S %z"),
  "\\]",
  ' "GET ',
  namedCapture.filetype.pattern, "?")

@ 

Overall both \CRANpkg{rex} and \CRANpkg{namedCapture} provide good
support for defining regular expresions using a verbose, readable, and
thus user-friendly syntax. However there are two major differences:
\begin{itemize}
\item \CRANpkg{namedCapture} assumes the user knows regular
  expressions and can write them as R string literals; \CRANpkg{rex}
  assumes the user knows its functions, which generate regex
  strings. For example the capture group time,
  \verb|none_of("]") %>% zero_or_more()| in rex gets translated to the
  regex string \verb|[^]]*|. Thus rex code is a bit more verbose than
  namedCapture.
\item In \CRANpkg{namedCapture} type conversion functions can be specified on the
  same line as the capture group name/pattern, whereas in \CRANpkg{rex} type conversions are
  specified as a post-processing step on the result of \code{re\_matches}. 
\end{itemize}

\subsection{Comparing \code{namedCapture::df\_match\_variable} with \code{tidyr::extract}}
\label{sec:tidyr}

The \CRANpkg{tidyr} package provides functionality similar to
\code{namedCapture::df\_match\_variable}, which was introduced in
Section~\ref{sec:df_match_variable}. Below we show how
\code{tidyr::extract} can be used to compute the same result as was
obtained in Section~\ref{sec:df_match_variable} on the data from the
SLURM sacct command line program. We begin by defining a pattern which
matches a range of integers in square brackets:

<<tidyr.range>>=

tidyr.range.pattern <- "\\[([0-9]+)(?:-([0-9]+))?\\]"
tidyr::extract(
  sacct.df, "JobID", c("task1", "taskN"), 
  tidyr.range.pattern, remove=FALSE)

@ 

Note the pattern string includes un-named capture groups, because
named capture is not supported. Names must therefore be specified in
the third argument of \code{extract}. Next, we define a pattern which
matches either a single task ID, or a range in square brackets:

<<tidyr.task>>=

tidyr.task.pattern <- paste0(
  "_(?:([0-9]+)|",
  tidyr.range.pattern, 
  ")")
tidyr::extract(
  sacct.df, "JobID", c("task", "task1", "taskN"), 
  tidyr.task.pattern, remove=FALSE)

@ 

In the code below we define a pattern that matches the entire job string:

<<tidyr.job>>=

tidyr.job.pattern <- paste0(
  "([0-9]+)", 
  tidyr.task.pattern,
  "(?:[.](.*))?")
(job.df <- tidyr::extract(
  sacct.df, "JobID", 
  c("job", "task", "task1", "taskN", "type"), 
  tidyr.job.pattern))

@ 

Finally, we use another pattern to extract the components of the
elapsed time. Note that \code{convert=TRUE} means to use
\code{utils::type.convert} on the result of each extracted group.

<<tidyr2>>=

tidyr::extract(
  job.df, "Elapsed", c("hours", "minutes", "seconds"),
  "([0-9]+):([0-9]+):([0-9]+)",
  convert=TRUE)

@

Overall \code{tidyr::extract} functions
similarly to
\code{namedCapture::df\_match\_variable}, with the following
differences:
\begin{itemize}
\item Because \code{tidyr::extract} uses the ICU C library, which does
  not support named capture groups, it requires specifying the group
  names in a separate argument. In contrast, the
  \CRANpkg{namedCapture} variable argument syntax supports specifying
  capture group names via R argument names on the same line as the
  corresponding sub-pattern.
\item Whereas \code{tidyr::extract(convert=TRUE)} always uses
  \code{utils::type.convert} for type conversion,
  \code{namedCapture::df\_match\_variable} supports arbitrary
  group-specific type conversion functions, which are specified on the
  same line as the corresponding name/pattern.
\item Because one call to \code{tidyr::extract} extracts data from one
  column in the subject data frame, it must be called twice (once for
  the Elapsed column, once for the JobID column). In contrast, one
  call to \code{namedCapture::df\_match\_variable} can be used to
  extract data from multiple columns in the subject data frame. 
\end{itemize}

\subsection{Comparing computation times of R regex packages}
\label{sec:timings}

In this section we compare the computation time of the proposed
namedCapture package with other R packages. For all of the
comparisons, we used the \CRANpkg{microbenchmark} package to compute
the computation times of each R package/function. We study how the empirical
computation time scales as a function of subject size. 

The first example involves extracting all matches from a multi-line
text file, as discussed in
Section~\ref{sec:trackDb}. Figure~\ref{fig:timings-examples} (left)
shows comparisons with packages \CRANpkg{re2r}, \CRANpkg{stringr},
\CRANpkg{stringi}, \CRANpkg{rematch2}, \CRANpkg{rex}). We expected
small differences between the packages, on the order of constant
factors. Surprisingly, the rex and rematch2 packages have larger
slopes than the other algorithms, which suggests quadratic rather than
the expected linear time complexity. This can be explained because these packages use the base
\code{gregexpr} and \code{substring} functions, which are implemented
using inefficient quadratic time algorithms in R-3.5.2 (a bug report
has been filed for base R as a result of this investigation).


\begin{figure}
  \includegraphics[width=\textwidth]{figure-timings-examples}
  \caption{\label{fig:timings-examples}
    Computation time is plotted as a function of subject size (median line and quartiles bands over 5 timings).
    }
\end{figure}

The second example involves extracting the first match from each line
of a log file, as discussed in
Section~\ref{sec:rex}. Figure~\ref{fig:timings-examples} (middle)
shows comparisons with the previously discussed packages and
\code{utils:strcapture}. We expected small differences between the
packages, on the order of constant factors. In this comparison we
observed only small constant factor differences between all packages.

The third example involves using a different regular expression to
extract data for each of two columns of a data frame, as discussed in
Section~\ref{sec:tidyr}. Figure~\ref{fig:timings-examples} (right)
shows a comparison with \CRANpkg{tidyr}. Again we expected small
differences between the packages, and we observed that \CRANpkg{tidyr}
is faster than \CRANpkg{namedCapture} by a small constant factor.

The final example involves using a pathological regular expression of
increasing size on a subject of increasing size. For size $N=1$ the
subject is \code{a} and the pattern is \code{a?a}; for $N=2$ the
subject is \code{aa} and the pattern is \code{a?a?aa}; etc. Although
these timings are not typical of real data, they illustrate the worst
case time complexity that can be achieved. Such information may be
useful to choose a regex library to avoid a denial-of-service attack,
in situations where (potentially malicious) users are permitted to
define the regular expression
pattern. Figure~\ref{fig:timings-pathological} shows a comparison
between PCRE, RE2, TRE, and ICU. Is is clear that the fastest
libraries are TRE and RE2, which exhibit linear time complexity. The
slowest algorithm is clearly ICU, which exhibits exponential time
complexity. The PCRE library is exponential up to a certain
pattern/subject size, after which it is constant, because of a limit
PCRE imposes on backtracking. Overall this comparison suggests that
for guaranteed fast matching, TRE or RE2 must be used. However TRE
does not support named capture groups, so RE2 should be preferred (Table~\ref{tab:regex-libraries}), via
the \CRANpkg{re2r} or \CRANpkg{namedCapture} packages. 

\begin{table}
  \begin{tabular}{ccccc}
    C library & PCRE & TRE & RE2 & ICU\\
    Named capture groups & yes & no & yes & no\\
    Worst case linear time & no & yes & yes & no
  \end{tabular}
  \caption{\label{tab:regex-libraries}
    Features of C libraries for regular expressions usable in R.
    }
\end{table}

\begin{figure}
  \includegraphics[width=\textwidth]{figure-timings-pathological}
  \caption{\label{fig:timings-pathological}
    Computation time is plotted as a function of subject/pattern size (median line and quartiles bands over 5 timings).
    }
\end{figure}

\section{Discussion and conclusions}

The article presented the \CRANpkg{namedCapture} package, along with
detailed comparisons with other R packages for regular expressions.  A
unique feature of \CRANpkg{namedCapture} package is its compact and
readable syntax for defining regular expressions in R code. We showed
how this syntax can be used to extract data tables from a variety of
non-tabular text data. Our comparisons showed how similar operations
can be performed by other R packages, often in a similar amount of
time. We also highlighted the advantages of the \CRANpkg{namedCapture}
package, which include support for arbitrary type conversion
functions, named output based on the \code{name} capture group, and
two regex engines (PCRE which is provided with base R, and RE2 which
has guaranteed linear time complexity). 

\bibliography{RJreferences}

\address{Author One\\
  Affiliation\\
  Address\\
  Country\\
  (ORCiD if desired)\\
  \email{author1@work}}

\address{Author Two\\
  Affiliation\\
  Address\\
  Country\\
  (ORCiD if desired)\\
  \email{author2@work}}

\address{Author Three\\
  Affiliation\\
  Address\\
  Country\\
  (ORCiD if desired)\\
  \email{author3@work}}

\end{article}

\end{document}
